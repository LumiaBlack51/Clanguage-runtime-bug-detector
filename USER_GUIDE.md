# C Safety Scanner 用户指南

## 概述

C Safety Scanner 是一个基于启发式分析的 C 代码安全扫描工具，用于检测常见的编程错误和安全问题。该工具使用行级正则表达式解析和分段哈希表来高效地分析 C 代码。

## 功能特性

### 1. 未初始化变量检测
**功能描述**: 检测变量在赋值前使用的情况。

**检测类型**:
- 局部变量未初始化使用
- 全局变量未初始化使用
- 静态变量未初始化使用

**示例**:
```c
int main() {
    int x;           // 声明但未初始化
    printf("%d", x); // BUG: 使用未初始化的变量
    return 0;
}
```

**检测结果**: `[Uninitialized] 变量使用前未初始化`

### 2. 野指针检测
**功能描述**: 检测未初始化指针的解引用操作。

**检测类型**:
- 直接解引用: `*ptr`
- 结构体成员访问: `ptr->field`
- 数组访问: `ptr[index]`

**示例**:
```c
int main() {
    int *ptr;        // 未初始化的指针
    *ptr = 42;       // BUG: 解引用野指针
    return 0;
}
```

**检测结果**: `[Wild pointer] 潜在野指针解引用（指针未初始化）`

### 3. 空指针检测
**功能描述**: 检测空指针的解引用操作。

**检测类型**:
- 初始化为 NULL 的指针解引用
- 初始化为 0 的指针解引用

**示例**:
```c
int main() {
    int *ptr = NULL; // 初始化为空指针
    *ptr = 42;       // BUG: 解引用空指针
    return 0;
}
```

**检测结果**: `[Wild pointer] 潜在野指针解引用（指针未初始化）`

### 4. 头文件拼写检查
**功能描述**: 检测非标准头文件名称的拼写错误。

**检测类型**:
- 标准头文件名拼写错误
- 非标准头文件使用

**示例**:
```c
#include <stdiox.h>  // BUG: 应该是 stdio.h
```

**检测结果**: `[Header] 可疑标准头文件: stdiox.h`

**支持的标准头文件**:
`assert.h`, `complex.h`, `ctype.h`, `errno.h`, `fenv.h`, `float.h`, `inttypes.h`, `iso646.h`, `limits.h`, `locale.h`, `math.h`, `setjmp.h`, `signal.h`, `stdalign.h`, `stdarg.h`, `stdatomic.h`, `stdbool.h`, `stddef.h`, `stdint.h`, `stdio.h`, `stdlib.h`, `stdnoreturn.h`, `string.h`, `tgmath.h`, `threads.h`, `time.h`, `uchar.h`, `wchar.h`, `wctype.h`

### 5. 死循环检测
**功能描述**: 通过模拟循环执行来检测潜在的死循环。

**检测类型**:
- 明显死循环: `for(;;)`, `while(1)`, `while(true)`
- 循环条件错误: 循环变量永远不会满足退出条件
- 步长问题: 循环变量步长过大或过小，跳过或无法达到退出条件
- 浮点精度问题: 浮点数循环由于精度问题无法达到目标值

**示例**:
```c
// 明显死循环
for(;;) {
    printf("infinite loop\n");
}

// 循环条件错误
for(int i = 10; i >= 10; i++) {
    printf("i = %d\n", i); // 永远不会退出
}

// 步长问题
for(int i = 0; i == 10; i += 3) {
    printf("i = %d\n", i); // i会变成0,3,6,9,12...永远不等于10
}
```

**检测结果**: `[Dead loop] 潜在死循环（循环条件无法满足退出条件）`

**检测规则**:
- 如果循环体内有`break`、`return`或`exit()`，不报告为死循环
- 模拟最多10万次迭代来检查循环是否能退出
- 支持常见的循环变量更新模式：`i++`, `i--`, `i += n`, `i -= n`
- 检查循环条件中的比较操作符：`<`, `<=`, `>`, `>=`, `==`, `!=`

### 6. 数值范围检查
**功能描述**: 检测赋值时数值是否超出变量类型范围。

**检测类型**:
- 整数类型范围溢出
- 十六进制数值范围检查
- 八进制数值范围检查
- 声明时初始化和赋值时范围检查

**支持的类型范围**:
- `char`: -128 到 127
- `unsigned char`: 0 到 255
- `short`: -32768 到 32767
- `unsigned short`: 0 到 65535
- `int`: -2147483648 到 2147483647
- `unsigned int`: 0 到 4294967295
- `long`: -2147483648 到 2147483647
- `unsigned long`: 0 到 4294967295
- `long long`: -9223372036854775808 到 9223372036854775807
- `unsigned long long`: 0 到 18446744073709551615
- `size_t`: 0 到 18446744073709551615

**示例**:
```c
char c1 = 128;        // BUG: 超出char范围(-128到127)
char c2 = 0x100;      // BUG: 0x100 = 256，超出char范围
char c3 = 0400;       // BUG: 0400 = 256，超出char范围
short s1 = 40000;     // BUG: 超出short范围(-32768到32767)
int i1 = 3000000000;  // BUG: 超出int范围
```

**检测结果**: `[Range overflow] 初始化数值超出[类型]类型范围`

### 7. 内存泄漏检测
**功能描述**: 检测堆内存分配后未释放的情况。

**检测类型**:
- `malloc()` 分配的内存未释放
- `calloc()` 分配的内存未释放
- `realloc()` 分配的内存未释放
- 函数结束时检查内存泄漏

**示例**:
```c
void test_memory_leak() {
    int *ptr = malloc(sizeof(int) * 10);  // 分配内存
    char *str = malloc(100);              // 分配内存
    
    // 使用内存
    ptr[0] = 42;
    strcpy(str, "Hello");
    
    // BUG: 忘记释放内存
    printf("ptr[0] = %d\n", ptr[0]);
    printf("str = %s\n", str);
    // 函数结束时检测到内存泄漏
}
```

**检测结果**: `[Memory leak] 内存泄漏：变量[变量名]分配的内存未释放`

**检测规则**:
- 跟踪 `malloc()`, `calloc()`, `realloc()` 调用
- 跟踪 `free()` 调用
- 在函数结束时检查未释放的内存
- 支持嵌套函数调用中的内存泄漏检测

### 8. printf/scanf 格式检查
**功能描述**: 检测 printf 和 scanf 函数中格式字符串与参数的不匹配。

**检测类型**:
- 参数数量少于格式化占位数
- 参数数量多于格式化占位数
- scanf 参数缺少地址操作符 `&`

**示例**:
```c
int x = 42;
printf("%d %s", x);           // BUG: 缺少一个参数
printf("%d", x, "extra");     // BUG: 多了一个参数
scanf("%d", x);               // BUG: 缺少 & 操作符
```

**检测结果**: 
- `[Format] printf 参数少于格式化占位数`
- `[Format] printf 参数多于格式化占位数`
- `[Format] scanf 实参建议传地址（使用 &var）`

## 使用方法

### 命令行使用

1. **编译项目**:
```bash
npm run compile
```

2. **扫描单个目录**:
```bash
node ./out/cli.js <目录路径>
```

3. **扫描测试集**:
```bash
# 扫描故障测试集
npm run scan:buggy

# 扫描正确测试集
npm run scan:correct
```

4. **生成报告**:
```bash
# 生成故障集报告
npm run report:buggy

# 生成正确集报告
npm run report:correct
```

### VS Code 扩展使用

1. **安装扩展**: 将 `.vsix` 文件安装到 VS Code
2. **扫描当前工作区**: 使用命令面板 `Ctrl+Shift+P`，输入 "C Safety Scanner: 扫描当前工作区"
3. **扫描主目录**: 使用命令面板，输入 "C Safety Scanner: 扫描主目录"

## 技术架构

### 核心方法
- **启发式解析**: 使用基于正则表达式的行级解析，稳定可靠
- **分段哈希表**: 使用4段哈希表优化变量查找性能 (a-f, g-m, n-s, t-z)
- **作用域管理**: 支持全局和函数局部作用域的变量管理

### 数据结构
```typescript
type VariableInfo = {
  name: string;           // 变量名
  typeName: string;       // 类型名（支持存储类说明符）
  isPointer: boolean;     // 是否为指针
  isInitialized: boolean; // 是否已初始化
  isArray?: boolean;      // 是否为数组
  pointerMaybeNull?: boolean; // 指针是否可能为NULL
};
```

### 性能优化
- **分段哈希表**: 将变量名按首字母分为4段，减少哈希冲突
- **正则表达式优化**: 预编译常用正则表达式
- **作用域缓存**: 缓存当前作用域的变量表

## 限制和注意事项

### 当前限制
1. **未实现的检测**:
   - 函数返回值检查
   - 更复杂的控制流分析
   - 跨函数的数据流分析

2. **误报原因**:
   - 按址传递参数的复杂场景识别不完整
   - 函数调用返回值的使用场景
   - 复杂表达式的变量使用检测

3. **漏报原因**:
   - 仅在使用时检测，不在声明时检测
   - 缺少高级控制流分析
   - 缺少跨函数的数据流分析

### 使用建议
1. **结合其他工具**: 建议与编译器警告、静态分析工具结合使用
2. **人工审查**: 对于复杂的代码逻辑，建议进行人工审查
3. **定期更新**: 保持工具的最新版本以获得最佳检测效果

## 测试和验证

### 测试文件结构
```
tests/graphs/
├── buggy/           # 故障测试集
│   ├── bug_0.c      # 基础测试用例
│   ├── bug_45.c     # 野指针和空指针测试
│   ├── bug_46.c     # 内存泄漏测试
│   ├── bug_47.c     # 数值范围检查测试
│   ├── bug_48.c     # 死循环检测测试
│   ├── bug_49.c     # 函数参数测试
│   ├── bug_50.c     # static/const变量测试
│   ├── graph.c      # 图操作函数（含多个BUG）
│   ├── graph.h      # 头文件
│   └── main.c       # 主程序
└── correct/         # 正确测试集
    ├── graph.c      # 正确的图操作
    ├── graph.h      # 头文件
    └── main.c       # 主程序
```

### 性能指标
当前版本性能指标:
- **Precision**: 高精度，误报率低
- **Recall**: 中等召回率，有少量漏报
- **F1**: 平衡的精确度和召回率

## 贡献和反馈

如果您发现 bug 或有改进建议，请：
1. 检查现有的测试用例
2. 创建新的测试用例来重现问题
3. 提交详细的错误报告
4. 提供修复建议

## 许可证

本项目采用 MIT 许可证。详情请参阅 LICENSE 文件。
